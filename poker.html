<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Texas Hold'em (2â€“4 Players) â€” Local Multiplayer</title>
  <style>
    :root{
      --bg:#0b1020; --panel:#121a33; --panel2:#0f1630; --text:#e6e8ef; --muted:#aab0c5;
      --accent:#6ee7b7; --warn:#fbbf24; --danger:#fb7185; --chip:#93c5fd; --card:#f8fafc; --card2:#e2e8f0;
    }
    *{ box-sizing:border-box; }
    body{
      margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Apple Color Emoji","Segoe UI Emoji";
      background: radial-gradient(1200px 800px at 30% 10%, #1b2a58 0%, var(--bg) 60%);
      color:var(--text);
    }
    header{
      padding:16px 18px; border-bottom:1px solid rgba(255,255,255,.08);
      display:flex; justify-content:space-between; align-items:center; gap:10px; flex-wrap:wrap;
    }
    header h1{ margin:0; font-size:18px; font-weight:700; letter-spacing:.3px; }
    header .sub{ color:var(--muted); font-size:13px; }
    main{ padding:16px; max-width:1100px; margin:0 auto; display:grid; grid-template-columns: 1.2fr .8fr; gap:14px; }
    @media(max-width:900px){ main{ grid-template-columns:1fr; } }
    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border:1px solid rgba(255,255,255,.10);
      border-radius:16px; padding:14px;
      box-shadow: 0 8px 24px rgba(0,0,0,.22);
    }
    .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    .grow{ flex:1; }
    .btn{
      border:1px solid rgba(255,255,255,.16);
      background: rgba(255,255,255,.07);
      color:var(--text);
      padding:10px 12px; border-radius:12px;
      cursor:pointer; font-weight:650; font-size:13px;
      transition: transform .05s ease, background .15s ease, border .15s ease;
      user-select:none;
    }
    .btn:hover{ background: rgba(255,255,255,.10); border-color: rgba(255,255,255,.22); }
    .btn:active{ transform: translateY(1px); }
    .btn.primary{ background: rgba(110,231,183,.18); border-color: rgba(110,231,183,.35); color:#eafff5; }
    .btn.warn{ background: rgba(251,191,36,.16); border-color: rgba(251,191,36,.36); }
    .btn.danger{ background: rgba(251,113,133,.14); border-color: rgba(251,113,133,.35); }
    .btn:disabled{ opacity:.45; cursor:not-allowed; }
    input, select{
      background: rgba(255,255,255,.07); border:1px solid rgba(255,255,255,.16);
      color:var(--text); padding:10px 10px; border-radius:12px;
      outline:none; font-size:13px;
    }
    label{ font-size:12px; color:var(--muted); display:block; margin-bottom:6px; }
    .pill{
      display:inline-flex; align-items:center; gap:8px;
      padding:8px 10px; border-radius:999px;
      background: rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.12);
      color:var(--muted); font-size:12px;
    }
    .players{
      display:grid; grid-template-columns: 1fr 1fr; gap:10px;
    }
    @media(max-width:520px){ .players{ grid-template-columns:1fr; } }
    .player{
      background: rgba(0,0,0,.14);
      border:1px solid rgba(255,255,255,.10);
      border-radius:14px;
      padding:10px;
      position:relative;
      min-height:118px;
    }
    .player.active{ outline: 2px solid rgba(110,231,183,.55); }
    .player.folded{ opacity:.55; }
    .p-top{ display:flex; justify-content:space-between; gap:10px; align-items:center; }
    .p-name{ font-weight:750; }
    .p-meta{ color:var(--muted); font-size:12px; }
    .chips{ color:var(--chip); font-weight:750; }
    .bet{ color:var(--warn); font-weight:750; }
    .status{
      position:absolute; top:10px; right:10px;
      font-size:11px; color:var(--muted);
    }
    .cards{ display:flex; gap:8px; margin-top:10px; }
    .pcard{
      width:46px; height:64px; border-radius:10px;
      background: linear-gradient(180deg, var(--card), var(--card2));
      color:#0b1020; display:flex; align-items:center; justify-content:center;
      font-weight:800; letter-spacing:.3px;
      border:1px solid rgba(15,23,42,.12);
      box-shadow: 0 6px 14px rgba(0,0,0,.20);
      font-size:14px;
    }
    .pcard.back{
      background: linear-gradient(180deg, rgba(147,197,253,.92), rgba(59,130,246,.75));
      color: rgba(255,255,255,.92);
      border:1px solid rgba(255,255,255,.18);
    }
    .board{
      display:flex; align-items:center; justify-content:space-between; gap:12px; flex-wrap:wrap;
      padding:10px; border-radius:14px; background: rgba(0,0,0,.14);
      border:1px solid rgba(255,255,255,.10);
    }
    .board .cards{ margin:0; }
    .pot{
      display:flex; flex-direction:column; gap:6px;
      padding:8px 10px; border-radius:14px;
      background: rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.12);
      min-width:180px;
    }
    .pot .big{ font-size:18px; font-weight:900; color:var(--warn); }
    .stage{ font-size:12px; color:var(--muted); }
    .log{
      height:320px; overflow:auto; padding:10px; border-radius:14px;
      background: rgba(0,0,0,.14); border:1px solid rgba(255,255,255,.10);
      font-size:12px; color:var(--muted);
      line-height:1.45;
    }
    .log b{ color:var(--text); }
    .hint{ color:var(--muted); font-size:12px; }
    .divider{ height:1px; background: rgba(255,255,255,.10); margin:10px 0; }
    .toast{
      position:fixed; left:50%; transform:translateX(-50%);
      bottom:16px; background: rgba(15,23,42,.92);
      border:1px solid rgba(255,255,255,.14);
      padding:10px 12px; border-radius:12px;
      box-shadow: 0 14px 36px rgba(0,0,0,.35);
      max-width: 96vw;
      display:none;
    }
    .toast.show{ display:block; }
    .toast .t{ font-weight:750; }
    .toast .s{ color:var(--muted); font-size:12px; margin-top:2px; }
    .kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size:11px; padding:2px 6px; border-radius:8px;
      background: rgba(255,255,255,.08); border:1px solid rgba(255,255,255,.12);
      color:var(--text);
    }
  </style>
</head>
<body>
<header>
  <div>
    <h1>Texas Hold'em (2â€“4 Players)</h1>
    <div class="sub">Local multiplayer (hot-seat) â€¢ No sign-in â€¢ No server needed</div>
  </div>
  <div class="row">
    <span class="pill">Tip: pass the device on your turn <span class="kbd">Enter</span> to confirm</span>
    <button class="btn" id="btnHelp">Rules</button>
    <button class="btn danger" id="btnReset">Reset</button>
  </div>
</header>

<main>
  <section class="card">
    <div class="row" id="setupRow">
      <div>
        <label>Players</label>
        <select id="playerCount">
          <option value="2">2 players</option>
          <option value="3">3 players</option>
          <option value="4" selected>4 players</option>
        </select>
      </div>
      <div>
        <label>Starting chips</label>
        <input id="startingChips" type="number" min="100" step="50" value="1000"/>
      </div>
      <div>
        <label>Small blind</label>
        <input id="smallBlind" type="number" min="1" step="1" value="10"/>
      </div>
      <div class="grow">
        <label>Player names (comma-separated)</label>
        <input id="names" type="text" value="Player 1, Player 2, Player 3, Player 4"/>
      </div>
      <button class="btn primary" id="btnStart">Start game</button>
    </div>

    <div class="divider"></div>

    <div class="board">
      <div>
        <div class="stage" id="stageLabel">Stage: â€”</div>
        <div class="cards" id="boardCards"></div>
      </div>
      <div class="pot">
        <div class="stage">Pot</div>
        <div class="big" id="potAmt">$0</div>
        <div class="stage">To call: <b id="toCall">$0</b> â€¢ Min raise: <b id="minRaise">$0</b></div>
      </div>
    </div>

    <div style="margin-top:12px" class="players" id="players"></div>

    <div class="divider"></div>

    <div class="row">
      <div class="grow">
        <div class="hint"><b id="turnLabel">â€”</b></div>
        <div class="hint" id="turnHint">Start a game to begin.</div>
      </div>
      <button class="btn" id="btnNewHand" disabled>New hand</button>
      <button class="btn warn" id="btnShowdown" disabled>Showdown</button>
    </div>

    <div class="divider"></div>

    <div class="row">
      <button class="btn danger" id="btnFold" disabled>Fold</button>
      <button class="btn" id="btnCheckCall" disabled>Check / Call</button>
      <div>
        <label>Bet / Raise</label>
        <input id="betAmt" type="number" min="0" step="1" value="0" style="width:140px"/>
      </div>
      <button class="btn primary" id="btnBetRaise" disabled>Bet / Raise</button>
      <button class="btn" id="btnAllIn" disabled>All-in</button>
    </div>

    <div class="hint" style="margin-top:10px">
      Keyboard: <span class="kbd">F</span> fold â€¢ <span class="kbd">C</span> call/check â€¢ <span class="kbd">R</span> bet/raise â€¢ <span class="kbd">A</span> all-in â€¢ <span class="kbd">N</span> new hand
    </div>
  </section>

  <aside class="card">
    <div class="row" style="justify-content:space-between">
      <div>
        <div style="font-weight:800">Hand log</div>
        <div class="sub">Actions & results</div>
      </div>
      <button class="btn" id="btnClearLog">Clear</button>
    </div>
    <div class="divider"></div>
    <div class="log" id="log"></div>

    <div class="divider"></div>
    <div style="font-weight:800">About this build</div>
    <div class="hint" style="margin-top:6px">
      This is a single-file website implementing a complete Texas Hold'em loop for <b>2â€“4 players</b> (local hot-seat).
      Includes blinds, betting rounds, all-ins, and a 7-card hand evaluator (checks all 5-card combos).
      <br/><br/>
      Want online multiplayer? You can add a WebSocket server; see notes at bottom of file.
    </div>
  </aside>
</main>

<div class="toast" id="toast">
  <div class="t" id="toastTitle"></div>
  <div class="s" id="toastSub"></div>
</div>

<script>
/** ===== Card / Poker helpers ===== **/
const RANKS = ['2','3','4','5','6','7','8','9','T','J','Q','K','A'];
const SUITS = ['â™£','â™¦','â™¥','â™ '];
const RANK_VALUE = Object.fromEntries(RANKS.map((r,i)=>[r,i+2])); // 2..14

function makeDeck(){
  const d=[];
  for(const s of SUITS) for(const r of RANKS) d.push({r,s});
  return d;
}
function shuffle(a){
  for(let i=a.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [a[i],a[j]]=[a[j],a[i]];
  }
  return a;
}
function fmtCard(c){ return c.r + c.s; }
function money(n){ return '$' + n; }

function combos(arr, k){
  const res=[];
  const n=arr.length;
  const idx = Array.from({length:k}, (_,i)=>i);
  while(true){
    res.push(idx.map(i=>arr[i]));
    let i=k-1;
    while(i>=0 && idx[i]===i+n-k) i--;
    if(i<0) break;
    idx[i]++;
    for(let j=i+1;j<k;j++) idx[j]=idx[j-1]+1;
  }
  return res;
}

/**
 * Rank a 5-card hand.
 * Returns {cat, tiebreak:Array<number>, name}
 * Higher cat better. tiebreak lexicographic.
 *
 * Categories:
 * 8 straight flush
 * 7 four of a kind
 * 6 full house
 * 5 flush
 * 4 straight
 * 3 three of a kind
 * 2 two pair
 * 1 one pair
 * 0 high card
 */
function rank5(cards){
  // values sorted desc
  const vals = cards.map(c=>RANK_VALUE[c.r]).sort((a,b)=>b-a);
  const suits = cards.map(c=>c.s);
  const isFlush = suits.every(s=>s===suits[0]);

  // counts
  const countMap = new Map();
  for(const v of vals) countMap.set(v, (countMap.get(v)||0)+1);
  const groups = [...countMap.entries()].sort((a,b)=>{
    // sort by count desc, then value desc
    if(b[1]!==a[1]) return b[1]-a[1];
    return b[0]-a[0];
  }); // [value,count]

  // straight (handle wheel A-5)
  const uniq = [...new Set(vals)].sort((a,b)=>b-a);
  let isStraight=false, highStraight=0;
  if(uniq.length===5){
    const max=uniq[0], min=uniq[4];
    if(max-min===4){
      isStraight=true; highStraight=max;
    } else {
      // wheel: A 5 4 3 2 => vals [14,5,4,3,2]
      const wheel = [14,5,4,3,2];
      if(uniq.join(',')===wheel.join(',')){
        isStraight=true; highStraight=5;
      }
    }
  }

  if(isStraight && isFlush){
    return {cat:8, tiebreak:[highStraight], name:'Straight Flush'};
  }
  if(groups[0][1]===4){
    const quad = groups[0][0];
    const kicker = groups.find(g=>g[0]!==quad)[0];
    return {cat:7, tiebreak:[quad,kicker], name:'Four of a Kind'};
  }
  if(groups[0][1]===3 && groups[1][1]===2){
    return {cat:6, tiebreak:[groups[0][0], groups[1][0]], name:'Full House'};
  }
  if(isFlush){
    return {cat:5, tiebreak:vals, name:'Flush'};
  }
  if(isStraight){
    return {cat:4, tiebreak:[highStraight], name:'Straight'};
  }
  if(groups[0][1]===3){
    const trips=groups[0][0];
    const kickers = groups.filter(g=>g[1]===1).map(g=>g[0]).sort((a,b)=>b-a);
    return {cat:3, tiebreak:[trips, ...kickers], name:'Three of a Kind'};
  }
  if(groups[0][1]===2 && groups[1][1]===2){
    const pairHigh = Math.max(groups[0][0], groups[1][0]);
    const pairLow  = Math.min(groups[0][0], groups[1][0]);
    const kicker = groups.find(g=>g[1]===1)[0];
    return {cat:2, tiebreak:[pairHigh, pairLow, kicker], name:'Two Pair'};
  }
  if(groups[0][1]===2){
    const pair=groups[0][0];
    const kickers = groups.filter(g=>g[1]===1).map(g=>g[0]).sort((a,b)=>b-a);
    return {cat:1, tiebreak:[pair, ...kickers], name:'One Pair'};
  }
  return {cat:0, tiebreak:vals, name:'High Card'};
}

function compareRank(a,b){
  if(a.cat!==b.cat) return a.cat-b.cat;
  const m=Math.max(a.tiebreak.length,b.tiebreak.length);
  for(let i=0;i<m;i++){
    const av=a.tiebreak[i]||0, bv=b.tiebreak[i]||0;
    if(av!==bv) return av-bv;
  }
  return 0;
}

function bestOf7(cards7){
  const fiveCombos = combos(cards7,5);
  let best = null, bestHand=null;
  for(const h of fiveCombos){
    const r = rank5(h);
    if(!best || compareRank(r,best)>0){
      best=r; bestHand=h;
    }
  }
  return {rank:best, hand:bestHand};
}

/** ===== Game state ===== **/
const STAGES = ['Pre-flop','Flop','Turn','River','Showdown'];
const game = {
  started:false,
  players:[], // {name, chips, bet, folded, allIn, cards:[], acted:false, handContrib:number}
  dealer:0,
  sb:10,
  bb:20,
  pot:0,
  deck:[],
  board:[],
  stage:0,
  turn:0,
  highestBet:0,
  lastAggressor:null, // index
  minRaise:0,
  handId:0,
  showdownDone:false,
  sidePots:[],
};

/** ===== UI elements ===== **/
const el = id=>document.getElementById(id);
const ui = {
  players: el('players'),
  board: el('boardCards'),
  stageLabel: el('stageLabel'),
  potAmt: el('potAmt'),
  toCall: el('toCall'),
  minRaise: el('minRaise'),
  turnLabel: el('turnLabel'),
  turnHint: el('turnHint'),
  betAmt: el('betAmt'),
  log: el('log'),
  toast: el('toast'),
  toastTitle: el('toastTitle'),
  toastSub: el('toastSub'),
  btnStart: el('btnStart'),
  btnNewHand: el('btnNewHand'),
  btnShowdown: el('btnShowdown'),
  btnFold: el('btnFold'),
  btnCheckCall: el('btnCheckCall'),
  btnBetRaise: el('btnBetRaise'),
  btnAllIn: el('btnAllIn'),
  btnReset: el('btnReset'),
  btnClearLog: el('btnClearLog'),
  btnHelp: el('btnHelp'),
};

/** ===== Logging & toast ===== **/
function log(msg){
  const t = new Date().toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
  ui.log.innerHTML += `<div><span style="opacity:.6">${t}</span> ${msg}</div>`;
  ui.log.scrollTop = ui.log.scrollHeight;
}
function toast(title, sub=''){
  ui.toastTitle.textContent = title;
  ui.toastSub.textContent = sub;
  ui.toast.classList.add('show');
  setTimeout(()=>ui.toast.classList.remove('show'), 2600);
}

/** ===== Core helpers ===== **/
function escapeHtml(s){
  return (s||'').replace(/[&<>"']/g, c=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[c]));
}
function aliveNotFolded(){
  return game.players.map((p,i)=>({p,i})).filter(x=>!x.p.folded);
}
function nextActive(from){
  const n=game.players.length;
  for(let k=1;k<=n;k++){
    const i=(from+k)%n;
    const p=game.players[i];
    if(!p.folded && !p.allIn && (p.chips>0)) return i;
  }
  return null;
}
function rotateDealer(){
  const n=game.players.length;
  for(let k=1;k<=n;k++){
    const i=(game.dealer+k)%n;
    if(game.players[i].chips>0) { game.dealer=i; return; }
  }
}
function nextIndexWithChips(start, steps){
  const n=game.players.length;
  let i=start, found=0;
  while(true){
    i=(i+1)%n;
    if(game.players[i].chips>0){
      found++;
      if(found===steps) return i;
    }
  }
}
function currentToCall(){
  const p=game.players[game.turn];
  return Math.max(0, game.highestBet - p.bet);
}
function onlyOneLeft(){
  return game.players.filter(p=>!p.folded).length===1;
}

/** Track contributions for side-pots */
function spendFromStack(idx, amt){
  const p=game.players[idx];
  const a=Math.min(amt, p.chips);
  p.chips-=a;
  p.bet+=a;
  p.handContrib+=a;
  if(p.chips===0) p.allIn=true;
  return a;
}
function collectBetsToPot(){
  let sum=0;
  for(const p of game.players){ sum += p.bet; p.bet=0; }
  game.pot += sum;
}
function postBlind(idx, amt){ spendFromStack(idx, amt); }

/** Betting round completion check */
function everyoneSettledOrAllIn(){
  const alive = aliveNotFolded();
  for(const {p} of alive){
    if(p.allIn) continue;
    if(p.bet !== game.highestBet) return false;
    if(!p.acted) return false;
  }
  return true;
}

/** ===== Start / Hand setup ===== **/
function startGame(){
  const count = parseInt(el('playerCount').value,10);
  const starting = Math.max(100, parseInt(el('startingChips').value||'1000',10));
  const sb = Math.max(1, parseInt(el('smallBlind').value||'10',10));
  const bb = sb*2;

  const namesRaw = el('names').value.split(',').map(s=>s.trim()).filter(Boolean);
  const names = [];
  for(let i=0;i<count;i++) names.push(namesRaw[i] || `Player ${i+1}`);

  game.started=true;
  game.players = names.map(n=>({name:n, chips:starting, bet:0, folded:false, allIn:false, cards:[], acted:false, handContrib:0}));
  game.dealer=0;
  game.sb=sb; game.bb=bb;
  game.handId=0;

  el('btnNewHand').disabled=false;
  log(`<b>Game started</b> â€” ${count} players â€¢ ${money(starting)} stacks â€¢ blinds ${money(sb)}/${money(bb)}.`);
  newHand();
}

function newHand(){
  const activeCount = game.players.filter(p=>p.chips>0).length;
  if(activeCount<2){
    const winner = game.players.reduce((a,b)=> a.chips>b.chips ? a : b);
    log(`<b>Game over.</b> Winner: <b>${winner.name}</b> with ${money(winner.chips)}.`);
    toast('Game over', `Winner: ${winner.name}`);
    disableActions();
    el('btnNewHand').disabled=true;
    el('btnShowdown').disabled=true;
    render();
    return;
  }

  if(game.handId>0) rotateDealer();

  game.handId++;
  game.deck = shuffle(makeDeck());
  game.board = [];
  game.stage = 0;
  game.pot = 0;
  game.showdownDone=false;
  game.sidePots=[];

  for(const p of game.players){
    p.folded = (p.chips<=0);
    p.allIn = false;
    p.cards = [];
    p.bet = 0;
    p.acted = false;
    p.handContrib = 0;
  }

  for(let r=0;r<2;r++){
    for(const p of game.players){
      if(p.folded) continue;
      p.cards.push(game.deck.pop());
    }
  }

  const sbIdx = nextIndexWithChips(game.dealer, 1);
  const bbIdx = nextIndexWithChips(game.dealer, 2);
  game.sbIdx = sbIdx;
  game.bbIdx = bbIdx;

  postBlind(sbIdx, game.sb);
  postBlind(bbIdx, game.bb);

  game.highestBet = game.bb;
  game.minRaise = game.bb;
  game.lastAggressor = bbIdx;

  game.turn = nextActive(bbIdx) ?? sbIdx;

  log(`<b>Hand #${game.handId}</b> â€” Dealer: <b>${game.players[game.dealer].name}</b>. Blinds posted: <b>${game.players[sbIdx].name}</b> ${money(game.sb)}, <b>${game.players[bbIdx].name}</b> ${money(game.bb)}.`);
  render();
  enableActions();
  updateTurnHint();
  toast('New hand', `Dealer: ${game.players[game.dealer].name}`);
}

/** ===== Actions ===== **/
function actFold(){
  const p=game.players[game.turn];
  p.folded=true;
  p.acted=true;
  log(`<b>${p.name}</b> folds.`);
  toast(`${p.name} folds`);
  if(onlyOneLeft()){ awardPotToLast(); return; }
  passTurn();
}

function actCheckCall(){
  const p=game.players[game.turn];
  const need = currentToCall();
  if(need===0){
    p.acted=true;
    log(`<b>${p.name}</b> checks.`);
    toast(`${p.name} checks`);
    passTurn();
    return;
  }
  const pay = spendFromStack(game.turn, need);
  p.acted=true;
  log(`<b>${p.name}</b> calls ${money(pay)}${pay<need?' (all-in)':''}.`);
  toast(`${p.name} calls`, money(pay));
  passTurn();
}

function actBetRaise(amount){
  const p=game.players[game.turn];
  amount = Math.floor(amount);
  if(!Number.isFinite(amount) || amount<=0){ toast('Enter a bet amount'); return; }

  const need = currentToCall();
  const totalPutIn = need + amount;
  const max = p.chips;
  const putIn = Math.min(totalPutIn, max);

  const isRaise = (game.highestBet>0);
  const minRaiseAmt = isRaise ? game.minRaise : game.bb;

  if(putIn < need + minRaiseAmt && putIn < max){
    toast('Raise too small', `Min raise is ${money(minRaiseAmt)} (after calling).`);
    return;
  }

  spendFromStack(game.turn, putIn);

  const newHighest = p.bet;
  const raiseSize = newHighest - game.highestBet;

  if(newHighest > game.highestBet){
    for(const q of game.players){
      if(q.folded || q.allIn) continue;
      q.acted=false;
    }
    p.acted=true;
    game.minRaise = Math.max(game.minRaise, raiseSize);
    game.highestBet = newHighest;
    game.lastAggressor = game.turn;

    log(`<b>${p.name}</b> ${isRaise?'raises':'bets'} to ${money(newHighest)}${p.allIn?' (all-in)':''}.`);
    toast(`${p.name} ${isRaise?'raises':'bets'}`, money(newHighest));
  } else {
    p.acted=true;
    log(`<b>${p.name}</b> calls ${money(putIn)} (all-in).`);
    toast(`${p.name} all-in`, money(putIn));
  }

  passTurn();
}

function actAllIn(){
  const p=game.players[game.turn];
  const all = p.chips;
  if(all<=0) return;
  const need = currentToCall();
  const raise = Math.max(0, all - need);
  if(need>0 && raise===0){
    actCheckCall();
  } else {
    actBetRaise(raise===0?1:raise);
  }
}

/** ===== Turn progression ===== **/
function awardPotToLast(){
  const winnerIdx = game.players.findIndex(p=>!p.folded);
  const w=game.players[winnerIdx];
  collectBetsToPot();
  w.chips += game.pot;
  log(`<b>${w.name}</b> wins ${money(game.pot)} (everyone else folded).`);
  toast('Hand won', `${w.name} takes ${money(game.pot)}`);
  game.pot=0;
  game.showdownDone=true;
  disableActions();
  el('btnShowdown').disabled=true;
  render();
}

function advanceStage(){
  collectBetsToPot();

  if(onlyOneLeft()){ awardPotToLast(); return; }

  if(game.stage===0){
    game.board.push(game.deck.pop(), game.deck.pop(), game.deck.pop());
    game.stage=1;
    log(`<b>Flop</b>: ${game.board.map(fmtCard).join(' ')}`);
  } else if(game.stage===1){
    game.board.push(game.deck.pop());
    game.stage=2;
    log(`<b>Turn</b>: ${fmtCard(game.board[3])}`);
  } else if(game.stage===2){
    game.board.push(game.deck.pop());
    game.stage=3;
    log(`<b>River</b>: ${fmtCard(game.board[4])}`);
  } else if(game.stage===3){
    game.stage=4;
    log(`<b>Showdown</b>.`);
    doShowdown();
    return;
  }

  for(const p of game.players){ p.acted=false; p.bet=0; }
  game.highestBet=0;
  game.lastAggressor=null;
  game.minRaise=game.bb;

  const first = nextActive(game.dealer) ?? nextActive(0) ?? 0;
  game.turn = first;
  render();
  enableActions();
  updateTurnHint();
}

function fastForwardToShowdown(){
  collectBetsToPot();
  while(game.board.length<5){
    if(game.board.length===0){
      game.board.push(game.deck.pop(), game.deck.pop(), game.deck.pop());
      log(`<b>Flop</b>: ${game.board.map(fmtCard).join(' ')}`);
    } else if(game.board.length===3){
      game.board.push(game.deck.pop());
      log(`<b>Turn</b>: ${fmtCard(game.board[3])}`);
    } else if(game.board.length===4){
      game.board.push(game.deck.pop());
      log(`<b>River</b>: ${fmtCard(game.board[4])}`);
    } else break;
  }
  game.stage=4;
  log(`<b>Showdown</b>.`);
  doShowdown();
}

function passTurn(){
  render();
  if(onlyOneLeft()){ awardPotToLast(); return; }

  if(everyoneSettledOrAllIn()){
    const canAct = game.players.some(p=>!p.folded && !p.allIn);
    if(!canAct){ fastForwardToShowdown(); return; }
    advanceStage();
    return;
  }

  const next = nextActive(game.turn);
  if(next===null){ fastForwardToShowdown(); return; }
  game.turn = next;
  updateTurnHint();
  render();
}

/** ===== Side pots + showdown ===== **/
function buildSidePots(){
  const contrib = game.players.map(p=>p.handContrib);
  const levels = [...new Set(contrib.filter(x=>x>0))].sort((a,b)=>a-b);
  const pots=[];
  let prev=0;
  for(const lvl of levels){
    const amountPerPlayer = lvl - prev;
    const contributors = game.players.map((p,i)=>({p,i})).filter(x=>x.p.handContrib>=lvl);
    const potAmt = amountPerPlayer * contributors.length;
    const eligible = contributors.filter(x=>!x.p.folded).map(x=>x.i);
    pots.push({amount:potAmt, eligible});
    prev=lvl;
  }
  return pots;
}

function doShowdown(){
  if(game.showdownDone) return;

  collectBetsToPot();
  const sidePots = buildSidePots();
  game.sidePots = sidePots;

  const results = [];
  for(let i=0;i<game.players.length;i++){
    const p=game.players[i];
    if(p.folded) continue;
    const seven = [...p.cards, ...game.board];
    const best = bestOf7(seven);
    results.push({i, best});
  }

  let totalAwarded=0;
  for(const sp of sidePots){
    if(sp.amount<=0) continue;
    const elig = results.filter(r=>sp.eligible.includes(r.i));
    if(elig.length===0) continue;

    let best = elig[0];
    for(const r of elig.slice(1)){
      if(compareRank(r.best.rank, best.best.rank)>0) best=r;
    }
    const winners = elig.filter(r=>compareRank(r.best.rank, best.best.rank)===0);

    const share = Math.floor(sp.amount / winners.length);
    const rem = sp.amount - share*winners.length;
    winners.forEach((w,idx)=>{
      const add = share + (idx<rem ? 1:0);
      game.players[w.i].chips += add;
      totalAwarded += add;
    });

    if(winners.length===1){
      log(`<b>${game.players[winners[0].i].name}</b> wins side pot ${money(sp.amount)} with <b>${best.best.rank.name}</b>.`);
    } else {
      log(`<b>Split pot</b> ${money(sp.amount)} between ${winners.map(w=>`<b>${game.players[w.i].name}</b>`).join(', ')} with <b>${best.best.rank.name}</b>.`);
    }
  }

  const potBefore = game.pot;
  game.pot = Math.max(0, game.pot - totalAwarded);

  for(const r of results){
    const p=game.players[r.i];
    log(`<b>${p.name}</b>: ${p.cards.map(fmtCard).join(' ')} â€” <b>${r.best.rank.name}</b>.`);
  }

  toast('Showdown complete', `${money(potBefore)} awarded`);
  game.showdownDone=true;
  disableActions();
  el('btnShowdown').disabled=true;
  render();
}

/** ===== UI rendering ===== **/
function render(){
  ui.stageLabel.textContent = 'Stage: ' + (game.started ? STAGES[game.stage] : 'â€”');

  ui.board.innerHTML='';
  const revealCount = game.stage===0 ? 0 : (game.stage===1 ? 3 : (game.stage===2 ? 4 : 5));
  for(let i=0;i<5;i++){
    const div=document.createElement('div');
    div.className='pcard ' + (i<revealCount ? '' : 'back');
    div.textContent = i<revealCount ? (game.board[i] ? fmtCard(game.board[i]) : '') : 'ðŸ‚ ';
    ui.board.appendChild(div);
  }

  const inBets = game.players.reduce((s,p)=>s+p.bet,0);
  ui.potAmt.textContent = money(game.pot + inBets);
  ui.toCall.textContent = money(game.started ? currentToCall() : 0);
  ui.minRaise.textContent = money(game.minRaise || game.bb || 0);

  ui.players.innerHTML='';
  if(!game.started) return;

  for(let i=0;i<game.players.length;i++){
    const p=game.players[i];
    const box=document.createElement('div');
    box.className='player' + (i===game.turn && !game.showdownDone ? ' active':'' ) + (p.folded ? ' folded':'');
    const role = (i===game.dealer?'D ':'') + (i===game.sbIdx?'SB ':'') + (i===game.bbIdx?'BB ':'');
    box.innerHTML = `
      <div class="p-top">
        <div>
          <div class="p-name">${escapeHtml(p.name)} <span class="status">${role}${p.allIn?'ALL-IN':''}</span></div>
          <div class="p-meta">Chips: <span class="chips">${money(p.chips)}</span> â€¢ Bet: <span class="bet">${money(p.bet)}</span></div>
        </div>
      </div>
      <div class="cards" id="cards-${i}"></div>
    `;
    ui.players.appendChild(box);

    const cardsDiv = box.querySelector(`#cards-${i}`);
    const show = (i===game.turn && !game.showdownDone) || game.stage===4 || p.folded;
    for(let c=0;c<2;c++){
      const cd=document.createElement('div');
      cd.className='pcard ' + (show ? '' : 'back');
      cd.textContent = show ? fmtCard(p.cards[c]) : 'ðŸ‚ ';
      cardsDiv.appendChild(cd);
    }
  }
}

function updateTurnHint(){
  if(!game.started){ ui.turnLabel.textContent='â€”'; ui.turnHint.textContent='Start a game to begin.'; return; }
  const p=game.players[game.turn];
  const need = currentToCall();
  const stage = STAGES[game.stage];
  ui.turnLabel.textContent = `Turn: ${p.name}`;
  ui.turnHint.textContent = `${stage} â€” ${need===0?'You can check or bet.':`To call: ${money(need)}.`} Dealer: ${game.players[game.dealer].name}.`;

  const suggested = need + (game.highestBet>0 ? game.minRaise : game.bb);
  ui.betAmt.value = Math.min(p.chips, Math.max(0, suggested));
}

function enableActions(){
  el('btnFold').disabled=false;
  el('btnCheckCall').disabled=false;
  el('btnBetRaise').disabled=false;
  el('btnAllIn').disabled=false;
  el('btnShowdown').disabled=false;
}
function disableActions(){
  el('btnFold').disabled=true;
  el('btnCheckCall').disabled=true;
  el('btnBetRaise').disabled=true;
  el('btnAllIn').disabled=true;
}

/** ===== Wire up UI ===== **/
el('btnStart').addEventListener('click', startGame);
el('btnNewHand').addEventListener('click', ()=>{ if(game.started) newHand(); });
el('btnFold').addEventListener('click', ()=>{ if(!game.showdownDone) actFold(); });
el('btnCheckCall').addEventListener('click', ()=>{ if(!game.showdownDone) actCheckCall(); });
el('btnBetRaise').addEventListener('click', ()=>{ if(!game.showdownDone) actBetRaise(parseInt(ui.betAmt.value||'0',10)); });
el('btnAllIn').addEventListener('click', ()=>{ if(!game.showdownDone) actAllIn(); });
el('btnShowdown').addEventListener('click', ()=>{ if(!game.showdownDone) fastForwardToShowdown(); });
el('btnReset').addEventListener('click', ()=>{ location.reload(); });
el('btnClearLog').addEventListener('click', ()=>{ ui.log.innerHTML=''; });
el('btnHelp').addEventListener('click', ()=>{
  alert(
`Texas Hold'em (quick rules)
- Each player gets 2 private cards.
- Five community cards are dealt (flop/turn/river).
- Best 5-card hand from your 2 + the 5 community wins.
Actions:
- Fold: give up the hand.
- Check: if nobody has bet this round.
- Call: match the current bet.
- Bet/Raise: increase the bet (min raise shown).
- All-in: put all remaining chips in.
This game supports side pots automatically for all-ins.`
  );
});

document.addEventListener('keydown', (e)=>{
  if(!game.started) return;
  if(e.key==='f' || e.key==='F') { if(!el('btnFold').disabled) el('btnFold').click(); }
  if(e.key==='c' || e.key==='C') { if(!el('btnCheckCall').disabled) el('btnCheckCall').click(); }
  if(e.key==='r' || e.key==='R') { if(!el('btnBetRaise').disabled) el('btnBetRaise').click(); }
  if(e.key==='a' || e.key==='A') { if(!el('btnAllIn').disabled) el('btnAllIn').click(); }
  if(e.key==='n' || e.key==='N') { if(!el('btnNewHand').disabled) el('btnNewHand').click(); }
  if(e.key==='Enter'){
    toast('Pass device', `It is ${game.players[game.turn].name}'s turn.`);
  }
});

render();
</script>
</body>
</html>

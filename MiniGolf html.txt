<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Mini Golf — Web</title>
  <style>
    :root {
      --bg: #0b1220;
      --panel: rgba(255,255,255,0.08);
      --text: rgba(255,255,255,0.92);
      --muted: rgba(255,255,255,0.65);
      --accent: #7dd3fc;
      --good: #86efac;
      --warn: #fca5a5;
    }
    html, body { height: 100%; margin: 0; background: radial-gradient(1200px 700px at 30% 20%, #14213d 0%, var(--bg) 55%, #070b14 100%); color: var(--text); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    .wrap { display: grid; grid-template-rows: auto 1fr; height: 100%; }
    header {
      display:flex; align-items:center; justify-content:space-between;
      padding: 12px 14px;
      background: linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.02));
      border-bottom: 1px solid rgba(255,255,255,0.10);
      gap: 12px;
    }
    .title { display:flex; flex-direction:column; line-height:1.1; }
    .title b { font-size: 14px; letter-spacing: 0.3px; }
    .title span { font-size: 12px; color: var(--muted); }
    .hud { display:flex; gap: 10px; flex-wrap: wrap; align-items:center; justify-content:flex-end; }
    .pill {
      background: var(--panel);
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 999px;
      padding: 6px 10px;
      font-size: 12px;
      display:flex; gap: 8px; align-items:center;
    }
    .pill .k { color: var(--muted); }
    button {
      background: rgba(125,211,252,0.14);
      border: 1px solid rgba(125,211,252,0.28);
      color: var(--text);
      border-radius: 10px;
      padding: 8px 10px;
      font-size: 12px;
      cursor: pointer;
      transition: transform 120ms ease, background 120ms ease;
      user-select:none;
    }
    button:hover { transform: translateY(-1px); background: rgba(125,211,252,0.20); }
    button:active { transform: translateY(0px); }
    main { position: relative; overflow:hidden; }
    #game { width: 100%; height: 100%; display:block; }
    .help {
      position:absolute; left: 12px; bottom: 12px;
      background: rgba(0,0,0,0.35);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 14px;
      padding: 10px 12px;
      font-size: 12px;
      color: rgba(255,255,255,0.85);
      backdrop-filter: blur(6px);
      max-width: 360px;
    }
    .help b { color: var(--accent); }
    .toast {
      position:absolute; top: 14px; left: 50%; transform: translateX(-50%);
      background: rgba(0,0,0,0.45);
      border: 1px solid rgba(255,255,255,0.14);
      border-radius: 999px;
      padding: 8px 12px;
      font-size: 12px;
      color: rgba(255,255,255,0.92);
      backdrop-filter: blur(6px);
      display:none;
      pointer-events:none;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="title">
        <b>Mini Golf</b>
        <span>Drag from the ball to aim • Release to shoot • Sink it in the cup</span>
      </div>
      <div class="hud">
        <div class="pill"><span class="k">Hole</span> <span id="holeNum">1</span>/<span id="holeTotal">3</span></div>
        <div class="pill"><span class="k">Strokes</span> <span id="strokes">0</span></div>
        <div class="pill"><span class="k">Par</span> <span id="par">3</span></div>
        <div class="pill"><span class="k">Total</span> <span id="total">0</span></div>
        <button id="resetBtn" title="Reset this hole (R)">Reset Hole</button>
        <button id="nextBtn" title="Skip to next hole (N)">Next Hole</button>
      </div>
    </header>

    <main>
      <canvas id="game"></canvas>
      <div class="toast" id="toast"></div>
      <div class="help">
        <div><b>How to play</b></div>
        <div>1) Click/touch <b>the ball</b>, drag to aim (farther = harder)</div>
        <div>2) Release to shoot • Try to finish in as few strokes as possible</div>
        <div style="margin-top:6px; color: rgba(255,255,255,0.72);">
          Keys: <b>R</b> reset hole • <b>N</b> next hole • <b>Space</b> re-center camera
        </div>
      </div>
    </main>
  </div>

  <!-- Matter.js -->
  <script src="https://cdn.jsdelivr.net/npm/matter-js@0.19.0/build/matter.min.js"></script>
  <script>
    (() => {
      const {
        Engine, Render, Runner, Bodies, Body, Composite, Events, Vector
      } = Matter;

      // ---------- Canvas / sizing ----------
      const canvas = document.getElementById('game');
      const main = canvas.parentElement;
      function resizeCanvas() {
        canvas.width = main.clientWidth;
        canvas.height = main.clientHeight;
        render.options.width = canvas.width;
        render.options.height = canvas.height;
        Render.lookAt(render, { min: { x: 0, y: 0 }, max: { x: W, y: H } });
      }

      // World dimensions (logical units). We scale to fit view.
      const W = 1200;
      const H = 700;

      // ---------- Engine / render ----------
      const engine = Engine.create();
      engine.gravity.y = 0; // top-down
      const world = engine.world;

      const render = Render.create({
        canvas,
        engine,
        options: {
          width: 800,
          height: 600,
          wireframes: false,
          background: 'transparent',
          pixelRatio: Math.min(window.devicePixelRatio || 1, 2),
          hasBounds: true
        }
      });

      const runner = Runner.create();
      Render.run(render);
      Runner.run(runner, engine);

      // ---------- UI ----------
      const holeNumEl = document.getElementById('holeNum');
      const holeTotalEl = document.getElementById('holeTotal');
      const strokesEl = document.getElementById('strokes');
      const parEl = document.getElementById('par');
      const totalEl = document.getElementById('total');
      const resetBtn = document.getElementById('resetBtn');
      const nextBtn = document.getElementById('nextBtn');
      const toastEl = document.getElementById('toast');

      function toast(msg, ms=1200) {
        toastEl.textContent = msg;
        toastEl.style.display = 'block';
        clearTimeout(toastEl._t);
        toastEl._t = setTimeout(() => toastEl.style.display = 'none', ms);
      }

      // ---------- Course styling ----------
      const colors = {
        turf: 'rgba(134, 239, 172, 0.10)',
        wall: 'rgba(255,255,255,0.22)',
        wallEdge: 'rgba(255,255,255,0.35)',
        ball: 'rgba(255,255,255,0.92)',
        ballStroke: 'rgba(0,0,0,0.30)',
        cup: 'rgba(0,0,0,0.55)',
        cupRing: 'rgba(255,255,255,0.18)',
        bumper: 'rgba(125,211,252,0.22)',
        bumperEdge: 'rgba(125,211,252,0.38)',
        hazard: 'rgba(252,165,165,0.12)'
      };

      // ---------- Holes (3) ----------
      // Each hole builds walls/obstacles, defines tee and cup positions.
      const holes = [
        {
          name: "Warm-up Lane",
          par: 3,
          tee: { x: 140, y: 350 },
          cup: { x: 1040, y: 350 },
          build: (add) => {
            add.wallsRect(60, 80, 1080, 540, 26);
            // gentle bumpers
            add.bumper(520, 260, 180, 26, 20);
            add.bumper(680, 440, 180, 26, -20);
          }
        },
        {
          name: "S-Curve",
          par: 4,
          tee: { x: 160, y: 540 },
          cup: { x: 1020, y: 160 },
          build: (add) => {
            add.wallsRect(60, 80, 1080, 540, 26);
            // inner walls to force curve
            add.wall(340, 140, 26, 360);
            add.wall(620, 280, 26, 360);
            add.wall(900, 140, 26, 360);
            // bumpers
            add.bumper(480, 520, 240, 26, 0);
            add.bumper(760, 80, 240, 26, 0);
          }
        },
        {
          name: "Pinball Pocket",
          par: 5,
          tee: { x: 180, y: 180 },
          cup: { x: 980, y: 520 },
          build: (add) => {
            add.wallsRect(60, 80, 1080, 540, 26);
            // hazards (visual only, but you can add penalty if you want)
            add.hazardZone(500, 350, 260, 160);

            // bumpers (angled)
            add.bumper(360, 250, 220, 26, 25);
            add.bumper(420, 470, 220, 26, -25);
            add.bumper(760, 250, 220, 26, -25);
            add.bumper(820, 470, 220, 26, 25);

            // tight pocket around cup
            add.wall(940, 430, 26, 220);
            add.wall(1080, 430, 26, 220);
            add.wall(1010, 620, 160, 26);
          }
        }
      ];

      holeTotalEl.textContent = holes.length;

      // ---------- Helpers to add bodies ----------
      const add = {
        wallsRect: (x, y, w, h, t) => {
          // rectangle boundary (x,y) top-left, w/h inner area
          add.wall(x, y, w, t);             // top
          add.wall(x, y + h, w, t);         // bottom
          add.wall(x, y, t, h);             // left
          add.wall(x + w, y, t, h);         // right
        },
        wall: (x, y, w, h) => {
          const cx = x + w/2, cy = y + h/2;
          const b = Bodies.rectangle(cx, cy, w, h, {
            isStatic: true,
            restitution: 0.9,
            friction: 0.0,
            render: {
              fillStyle: colors.wall,
              strokeStyle: colors.wallEdge,
              lineWidth: 1
            }
          });
          Composite.add(world, b);
          courseBodies.push(b);
          return b;
        },
        bumper: (cx, cy, w, h, angleDeg=0) => {
          const b = Bodies.rectangle(cx, cy, w, h, {
            isStatic: true,
            angle: angleDeg * Math.PI/180,
            restitution: 1.05,
            friction: 0.0,
            render: {
              fillStyle: colors.bumper,
              strokeStyle: colors.bumperEdge,
              lineWidth: 1
            }
          });
          Composite.add(world, b);
          courseBodies.push(b);
          return b;
        },
        hazardZone: (cx, cy, w, h) => {
          // purely visual: a static sensor rectangle
          const b = Bodies.rectangle(cx, cy, w, h, {
            isStatic: true,
            isSensor: true,
            render: {
              fillStyle: colors.hazard,
              strokeStyle: 'rgba(252,165,165,0.25)',
              lineWidth: 1
            }
          });
          Composite.add(world, b);
          courseBodies.push(b);
          return b;
        }
      };

      // ---------- Ball & Cup ----------
      const BALL_R = 16;
      const CUP_R = 18;     // visual ring
      const CUP_HIT_R = 14; // "sink" radius

      let ball = null;
      let cup = null;
      let cupRing = null;
      let courseBodies = [];

      // ---------- Gameplay state ----------
      let holeIndex = 0;
      let strokes = 0;
      let totalStrokes = 0;

      // Aim / shot
      let isAiming = false;
      let aimStart = null;
      let aimNow = null;

      // Tuning
      const MAX_PULL = 200;          // max drag distance (power cap)
      const POWER_MULT = 0.055;      // force multiplier
      const STOP_SPEED = 0.35;       // ball considered "stopped" below this
      const LINE_FADE_WHEN_MOVING = true;

      function setHUD() {
        holeNumEl.textContent = (holeIndex + 1);
        parEl.textContent = holes[holeIndex].par;
        strokesEl.textContent = strokes;
        totalEl.textContent = totalStrokes;
      }

      function clearCourse() {
        Composite.remove(world, courseBodies);
        courseBodies = [];
        if (ball) Composite.remove(world, ball);
        if (cup) Composite.remove(world, cup);
        if (cupRing) Composite.remove(world, cupRing);
        ball = cup = cupRing = null;
      }

      function buildHole(i) {
        holeIndex = (i + holes.length) % holes.length;
        strokes = 0;
        clearCourse();

        // Turf (big sensor for visual)
        const turf = Bodies.rectangle(W/2, H/2, W, H, {
          isStatic: true,
          isSensor: true,
          render: { fillStyle: colors.turf }
        });
        Composite.add(world, turf);
        courseBodies.push(turf);

        holes[holeIndex].build(add);

        // Cup (sensor)
        const c = holes[holeIndex].cup;
        cup = Bodies.circle(c.x, c.y, CUP_HIT_R, {
          isStatic: true,
          isSensor: true,
          render: { visible: false }
        });
        Composite.add(world, cup);

        // Cup ring visual
        cupRing = Bodies.circle(c.x, c.y, CUP_R, {
          isStatic: true,
          isSensor: true,
          render: {
            fillStyle: colors.cup,
            strokeStyle: colors.cupRing,
            lineWidth: 2
          }
        });
        Composite.add(world, cupRing);

        // Ball
        const t = holes[holeIndex].tee;
        ball = Bodies.circle(t.x, t.y, BALL_R, {
          restitution: 0.65,
          frictionAir: 0.06,      // "turf drag"
          friction: 0.02,
          render: {
            fillStyle: colors.ball,
            strokeStyle: colors.ballStroke,
            lineWidth: 1
          }
        });
        // Keep ball from spinning too wildly (optional feel)
        Body.setInertia(ball, Infinity);
        Composite.add(world, ball);

        setHUD();
        toast(`Hole ${holeIndex + 1}: ${holes[holeIndex].name}`, 1400);
        centerView();
      }

      function centerView() {
        Render.lookAt(render, { min: { x: 0, y: 0 }, max: { x: W, y: H } });
      }

      function ballMoving() {
        if (!ball) return false;
        const v = ball.velocity;
        return Math.hypot(v.x, v.y) > STOP_SPEED;
      }

      function screenToWorld(clientX, clientY) {
        // Convert screen coords to world coords with Matter.Render bounds transform
        const rect = canvas.getBoundingClientRect();
        const x = (clientX - rect.left) * (render.bounds.max.x - render.bounds.min.x) / rect.width + render.bounds.min.x;
        const y = (clientY - rect.top)  * (render.bounds.max.y - render.bounds.min.y) / rect.height + render.bounds.min.y;
        return { x, y };
      }

      function isPointOnBall(p) {
        if (!ball) return false;
        const dx = p.x - ball.position.x;
        const dy = p.y - ball.position.y;
        return (dx*dx + dy*dy) <= (BALL_R*BALL_R * 1.2);
      }

      function clampPull(vec) {
        const len = Vector.magnitude(vec);
        if (len <= MAX_PULL) return vec;
        return Vector.mult(Vector.normalise(vec), MAX_PULL);
      }

      function takeShot(pullVec) {
        // pullVec points from ball toward drag point; we want force opposite that
        const clamped = clampPull(pullVec);
        const force = Vector.mult(clamped, -POWER_MULT);
        Body.applyForce(ball, ball.position, force);
        strokes += 1;
        setHUD();
      }

      // ---------- Input ----------
      function onPointerDown(e) {
        if (!ball) return;
        if (ballMoving()) return; // no aiming while rolling
        const p = screenToWorld(e.clientX, e.clientY);
        if (!isPointOnBall(p)) return;
        isAiming = true;
        aimStart = { x: ball.position.x, y: ball.position.y };
        aimNow = p;
      }

      function onPointerMove(e) {
        if (!isAiming) return;
        aimNow = screenToWorld(e.clientX, e.clientY);
      }

      function onPointerUp(e) {
        if (!isAiming) return;
        isAiming = false;
        const p = screenToWorld(e.clientX, e.clientY);
        aimNow = p;

        // pull vector from ball to drag point
        const pull = Vector.sub(aimNow, aimStart);
        const len = Vector.magnitude(pull);
        if (len < 6) return; // tiny drags do nothing
        takeShot(pull);
      }

      canvas.addEventListener('pointerdown', onPointerDown);
      window.addEventListener('pointermove', onPointerMove);
      window.addEventListener('pointerup', onPointerUp);

      // Keys
      window.addEventListener('keydown', (e) => {
        if (e.key.toLowerCase() === 'r') resetHole();
        if (e.key.toLowerCase() === 'n') nextHole();
        if (e.key === ' ') { e.preventDefault(); centerView(); }
      });

      resetBtn.addEventListener('click', () => resetHole());
      nextBtn.addEventListener('click', () => nextHole());

      function resetHole() {
        buildHole(holeIndex);
      }
      function nextHole() {
        buildHole(holeIndex + 1);
      }

      // ---------- Sink detection ----------
      let hasScored = false;

      Events.on(engine, 'beforeUpdate', () => {
        if (!ball || !cup) return;

        // Keep ball inside world bounds just in case
        if (ball.position.x < -200 || ball.position.x > W + 200 || ball.position.y < -200 || ball.position.y > H + 200) {
          toast('Out of bounds — resetting ball', 1200);
          buildHole(holeIndex);
          return;
        }

        if (hasScored) return;

        // If ball close enough to cup AND slow enough => sink
        const dx = ball.position.x - cup.position.x;
        const dy = ball.position.y - cup.position.y;
        const dist = Math.hypot(dx, dy);
        const speed = Math.hypot(ball.velocity.x, ball.velocity.y);

        if (dist <= CUP_HIT_R && speed < 2.0) {
          hasScored = true;

          // "drop" animation effect: shrink & fade
          const startR = BALL_R;
          let t = 0;
          const shrink = () => {
            if (!ball) return;
            t += 1;
            const k = Math.max(0, 1 - t/22);
            const r = Math.max(2, startR * k);
            Body.scale(ball, r / (ball.circleRadius || startR), r / (ball.circleRadius || startR));
            ball.circleRadius = r;
            ball.render.opacity = k;
            if (t < 22) requestAnimationFrame(shrink);
            else finishHole();
          };
          shrink();
        }
      });

      function finishHole() {
        const par = holes[holeIndex].par;
        totalStrokes += strokes;
        setHUD();

        const diff = strokes - par;
        const label =
          diff <= -2 ? 'Eagle!' :
          diff === -1 ? 'Birdie!' :
          diff === 0 ? 'Par!' :
          diff === 1 ? 'Bogey' :
          diff === 2 ? 'Double bogey' : `+${diff}`;

        toast(`${label}  •  ${strokes} strokes`, 1600);

        // Brief pause then advance (or end)
        setTimeout(() => {
          if (holeIndex === holes.length - 1) {
            toast(`Course complete! Total strokes: ${totalStrokes}`, 2200);
            // Restart course after a moment
            setTimeout(() => {
              totalStrokes = 0;
              buildHole(0);
              toast('New round started', 1400);
            }, 900);
          } else {
            buildHole(holeIndex + 1);
          }
          hasScored = false;
        }, 900);
      }

      // Reset score flag when hole rebuilds
      function buildHoleWithFlag(i) {
        hasScored = false;
        buildHole(i);
      }
      // Replace callers to ensure flag resets
      buildHole = buildHoleWithFlag;

      // ---------- Draw aim line ----------
      const ctx = canvas.getContext('2d');

      Events.on(render, 'afterRender', () => {
        if (!ball) return;

        // Cup highlight ring (subtle extra glow)
        ctx.save();
        ctx.globalAlpha = 0.35;
        ctx.beginPath();
        ctx.arc(cupRing.position.x, cupRing.position.y, CUP_R + 8, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(125,211,252,0.35)';
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.restore();

        const moving = ballMoving();
        if (LINE_FADE_WHEN_MOVING && moving) return;

        if (isAiming && aimStart && aimNow) {
          const pull = Vector.sub(aimNow, aimStart);
          const clamped = clampPull(pull);
          const power = Vector.magnitude(clamped) / MAX_PULL;

          const end = Vector.add(aimStart, clamped);

          // Aim line
          ctx.save();
          ctx.lineCap = 'round';

          // line
          ctx.globalAlpha = 0.85;
          ctx.beginPath();
          ctx.moveTo(aimStart.x, aimStart.y);
          ctx.lineTo(end.x, end.y);
          ctx.strokeStyle = 'rgba(255,255,255,0.60)';
          ctx.lineWidth = 4;
          ctx.stroke();

          // arrow head
          const dir = Vector.normalise(clamped);
          const left = Vector.rotate(dir, Math.PI * 0.75);
          const right = Vector.rotate(dir, -Math.PI * 0.75);
          const headLen = 14 + 10 * power;
          ctx.beginPath();
          ctx.moveTo(end.x, end.y);
          ctx.lineTo(end.x + left.x * headLen, end.y + left.y * headLen);
          ctx.lineTo(end.x + right.x * headLen, end.y + right.y * headLen);
          ctx.closePath();
          ctx.fillStyle = 'rgba(255,255,255,0.60)';
          ctx.fill();

          // power text
          ctx.globalAlpha = 0.95;
          ctx.font = '12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial';
          ctx.fillStyle = power > 0.85 ? 'rgba(252,165,165,0.95)' : 'rgba(134,239,172,0.95)';
          ctx.fillText(`Power ${(power*100|0)}%`, aimStart.x + 18, aimStart.y - 18);

          ctx.restore();
        }
      });

      // ---------- Init / resize ----------
      window.addEventListener('resize', resizeCanvas);
      resizeCanvas();

      // Build first hole
      // (call the internal builder directly once)
      (function init(){
        // temporary direct call to original builder behavior
        const origBuild = (i) => {
          holeIndex = (i + holes.length) % holes.length;
          strokes = 0;
          clearCourse();

          const turf = Bodies.rectangle(W/2, H/2, W, H, {
            isStatic: true,
            isSensor: true,
            render: { fillStyle: colors.turf }
          });
          Composite.add(world, turf);
          courseBodies.push(turf);

          holes[holeIndex].build(add);

          const c = holes[holeIndex].cup;
          cup = Bodies.circle(c.x, c.y, CUP_HIT_R, { isStatic:true, isSensor:true, render:{ visible:false }});
          Composite.add(world, cup);

          cupRing = Bodies.circle(c.x, c.y, CUP_R, {
            isStatic:true, isSensor:true,
            render: { fillStyle: colors.cup, strokeStyle: colors.cupRing, lineWidth:2 }
          });
          Composite.add(world, cupRing);

          const t = holes[holeIndex].tee;
          ball = Bodies.circle(t.x, t.y, BALL_R, {
            restitution: 0.65,
            frictionAir: 0.06,
            friction: 0.02,
            render: { fillStyle: colors.ball, strokeStyle: colors.ballStroke, lineWidth:1 }
          });
          Body.setInertia(ball, Infinity);
          Composite.add(world, ball);

          setHUD();
          toast(`Hole ${holeIndex + 1}: ${holes[holeIndex].name}`, 1400);
          centerView();
        };

        hasScored = false;
        totalStrokes = 0;
        origBuild(0);

        // now overwrite exported buildHole properly with flag reset
        buildHole = (i) => { hasScored = false; origBuild(i); };
      })();
    })();
  </script>
</body>
</html>